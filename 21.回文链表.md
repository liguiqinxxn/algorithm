### 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

<pre><strong>输入：</strong>head = [1,2,2,1]
<strong>输出：</strong>true
</pre>

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

<pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>false
</pre>

**提示：**

* 链表中节点数目在范围 `[1, 10<sup>5</sup>]` 内
* `0 <= Node.val <= 9`

 **进阶：** 你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？


### 时间复杂度O(n) 空间复杂度O(n)
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    let arr = []
    let current = head
    while (current) {
        arr.push(current.val)
        current = current.next
    }
    let left = 0, right = arr.length - 1
    while (left < right) {
        if (arr[left] != arr[right]) {
            return false
        }
        left++
        right--
    }
    return true
};
```

### 时间复杂度O(n) 空间复杂度O(1)
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
// 反转链
const reverseList = (head) => {
    let current = head, prev = null
    while (current) {
        const next = current.next
        current.next = prev
        prev = current
        current = next
    }
    return prev
}
// 找前一半的最后一个
const endOfFirstHalf = (head) => {
    let fast = head
    let slow = head
    while (fast.next !== null && fast.next.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow
}
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    if (head == null) return true
    const firstHalfEnd = endOfFirstHalf(head)
    const secondHalfStart = reverseList(firstHalfEnd.next)

    // 判断是否回文 
    let p1 = head;
    let p2 = secondHalfStart;
    let result = true;
    while (result && p2 != null) {
        if (p1.val != p2.val) result = false
        p1 = p1.next;
        p2 = p2.next;
    }

    firstHalfEnd.next = reverseList(secondHalfStart);
    return result
};
```

