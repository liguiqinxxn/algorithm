### 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**

 **输入：** **root = [1,2,3,null,5,null,4]**

 **输出：** **[1,3,4]**

**解释：**

![](https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png)

**示例 2：**

 **输入：** **root = [1,2,3,4,null,null,null,5]**

 **输出：** **[1,3,4,5]**

**解释：**

![](https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png)

**示例 3：**

 **输入：** **root = [1,null,3]**

 **输出：** **[1,3]**

**示例 4：**

 **输入：** **root = []**

 **输出：** **[]**

**提示:**

* 二叉树的节点个数的范围是 `[0,100]`
* `-100 <= Node.val <= 100`

### 广度优先遍历 时间复杂度O(n) 空间复杂度O(n)
```javascript
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 层序遍历获取每层最右侧节点的值
 */
var rightSideView = function (root) {
    if (!root) return []; // 如果根节点为空，返回空数组
    let result = [];       // 存储最终结果
    let queue = [root];    // 队列用于层序遍历
    while (queue.length) {
        let len = queue.length; // 当前层的节点数
        for (let i = 0; i < len; i++) {
            let node = queue.shift(); // 取出队首节点
            // 如果是当前层的最后一个节点，则加入结果
            if (i === len - 1) {
                result.push(node.val);
            }
            // 左右子节点依次入队，保证下一层遍历
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
    }
    return result; // 返回每一层最右侧节点值
};
```

### 深度优先遍历 时间复杂度O(n) 空间复杂度O(H)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {
    let result = []
    function dfs(node, depth) {
        if (!node) return;
        if (depth === result.length) {
            result.push(node.val)
        }
        dfs(node.right, depth + 1);
        dfs(node.left, depth + 1);
    }
    dfs(root, 0)
    return result
};
```
